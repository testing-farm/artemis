# source: https://gitlab.com/testing-farm/artemis/tree/master/container/Dockerfile.gitlab-ci
image: quay.io/testing-farm/gitlab-ci-artemis

stages:
  - test
  - deploy

tests:
  stage: test
  script:
    - wget -O - https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python3
    - source $HOME/.poetry/env
    # Force poetry to create its virtualenvs inside project directory, to avoid complications
    # when trying to leave our current directory when running in Gitlab.
    - poetry config virtualenvs.in-project true

    - cd server && IN_TEST=yes tox -v

.docs:
  image: registry.gitlab.com/pages/hugo:latest

  variables:
    # Theme is linked into docs/themes as a git submodule, and Gitlab is smart enough
    # to check it out for us, before we let Hugo run.
    GIT_SUBMODULE_STRATEGY: recursive
    
  script:
    - apk add asciidoctor
    - cd docs
    - hugo

    # TODO: here we should generate developer docs from sources, for both client and server.
    # We'd use Sphinx for that, and we'd need to store the output in - now empty - directories,
    # so we could link to these autogenerated bits from the "static" docs.

    # Gitlab expects "public" directory to appear in the local directory of the script,
    # which means that we need to move our one level up, since we're working in ./docs.
    - mv ./public ../

  artifacts:
    paths:
      - public

# The name must be "pages" for Gitlab to spot it, and upload the docs.
pages:
  stage: deploy
  extends: .docs
  only:
    - master
    - bootstrap-docs

# And this one's for uploading built docs for a preview.
pages-preview:
  stage: deploy
  extends: .docs
  except:
    - master
#    - bootstrap-docs

publish_apiary:
  image: "ruby:2.4"

  stage: deploy
  script:
    - gem install apiaryio
    - apiary publish --api-name="artemis6" --path "api/apiary.apib"
  only:
    - master
