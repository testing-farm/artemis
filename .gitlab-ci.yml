# source: https://gitlab.com/testing-farm/artemis/tree/master/container/Dockerfile.gitlab-ci
image: quay.io/testing-farm/gitlab-ci-artemis

stages:
  - test_stage
  - deploy

tests:
  stage: test_stage
  script:
    - wget -O - https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python3
    - source $HOME/.poetry/env
    # Force poetry to create its virtualenvs inside project directory, to avoid complications
    # when trying to leave our current directory when running in Gitlab.
    - poetry config virtualenvs.in-project true

    - cd server
    - IN_TEST=yes tox -v

    # Once we polish client/, we would start using shared pre-commit instance. For now, Tox already installed one for
    # us, we can use it.
    - git ls-files -- . | xargs -n100 .tox/py37/bin/pre-commit run --files

container:
  stage: test_stage
  image: quay.io/buildah/stable:latest
  script:
    - buildah bud -f container/Dockerfile .

.docs:
  image: registry.gitlab.com/pages/hugo:latest

  variables:
    # Theme is linked into docs/themes as a git submodule, and Gitlab is smart enough
    # to check it out for us, before we let Hugo run.
    GIT_SUBMODULE_STRATEGY: recursive

  script:
    - apk add asciidoctor

    # To get nicer HTML output, we need a bit more work.
    # For motivation, see https://blog.anoff.io/2019-02-17-hugo-render-asciidoc/

    # Install better HTML backend for asciidoctor
    - gem install asciidoctor-html5s

    # Replace actual asciidoctor script with our wrapper, to call it with options Hugo won't allow us to use.
    - mv /usr/bin/asciidoctor /usr/bin/asciidoctor.actual
    - printf '#!/bin/sh\n/usr/bin/asciidoctor.actual -r asciidoctor-html5s -b html5s "$@"\n' > /usr/bin/asciidoctor
    - chmod +x /usr/bin/asciidoctor

    # Now it's time to generate docs.
    - cd docs

    # Base URL is set by derived jobs. It's either the public one, when we're generating docs from `master` branch,
    # or it is a base URL of URL Gitlab uses when letting us browse artifacts job saved.
    - hugo --baseURL="$BASE_URL"

    # TODO: here we should generate developer docs from sources, for both client and server.
    # We'd use Sphinx for that, and we'd need to store the output in - now empty - directories,
    # so we could link to these autogenerated bits from the "static" docs.

    # Gitlab expects "public" directory to appear in the local directory of the script,
    # which means that we need to move our one level up, since we're working in ./docs.
    - mv ./public ../

  artifacts:
    paths:
      - public

# The name must be "pages" for Gitlab to spot it, and upload the docs.
pages:
  stage: deploy
  extends: .docs
  only:
    - master

  variables:
    BASE_URL: "https://${CI_PROJECT_NAMESPACE}.gitlab.io/${CI_PROJECT_NAME}"

  # This tells Gitlab to create an environment (under https://gitlab.com/testing-farm/artemis/-/environments) where
  # this particular job would be available. It is a common "Gitlab pages" environment, nothing special.
  environment:
    name: production/${CI_PROJECT_NAME}/${CI_COMMIT_REF_NAME}
    url: https://${CI_PROJECT_NAMESPACE}.gitlab.io/${CI_PROJECT_NAME}

# This job's for uploading built docs for a preview: into their own Gitlab environment. Note the `environment.url`
# value, which is different that the one for `master` branch - it is actually URL Gitlab uses when job saves
# its artifacts, and Gitlab lets us browse them.
pages:preview:
  stage: deploy
  extends: .docs
  except:
    - master

  variables:
    # Note that this URL matches the environment URL below - this lets us easily to get from the environment
    # we have in our MR to the actual pages.
    BASE_URL: "https://${CI_PROJECT_NAMESPACE}.gitlab.io/-/${CI_PROJECT_NAME}/-/jobs/${CI_JOB_ID}/artifacts/public"

    # By default, Hugo generates "nice" URLs: `content/foo.adoc` becomes `/foo/index.html`, and people
    # can then link to `/foo` because webservers will take care of providing the "index: of this directory,
    # `index.html`. This does not work with previews, though, as Gitlab pages preview won't supply that
    # directory index. To workaround this, we therefore enable "ugly" URLs: `content/foo.adoc` becomes
    # `/foo.html`, and all links point to `/foo.html` instead of `/foo/`.
    #
    # Note that this workaround does build site in a slightly different way that the actual public version,
    # and although highly unlikely, it *may* affect how the site works - Hugo is smart enough to take care
    # of this URL switching, and pages just work, but be aware the preview is not exactly the same as the final
    # site in this regard. For example, never link to internal pages directly using their rendered names like
    # `/foo.html`.
    HUGO_UGLYURLS: "true"

  environment:
    name: preview/${CI_PROJECT_NAME}/${CI_COMMIT_REF_NAME}
    url: https://${CI_PROJECT_NAMESPACE}.gitlab.io/-/${CI_PROJECT_NAME}/-/jobs/${CI_JOB_ID}/artifacts/public/index.html
    on_stop: pages:preview:stop

# And final step: when our parent MR is merged, this job takes care of removing the Gitlab environment \o/
pages:preview:stop:
  stage: deploy
  except:
    - master
  when: manual
  allow_failure: true
  environment:
    name: preview/${CI_PROJECT_NAME}/${CI_COMMIT_REF_NAME}
    action: stop
  script:
    - echo "bye"

publish_apiary:
  image: "ruby:2.4"

  stage: deploy
  script:
    - gem install apiaryio
    - apiary publish --api-name="artemis6" --path "api/apiary.apib"
  only:
    - master
